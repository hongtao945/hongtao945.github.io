<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/01/11/Redis%E7%9A%845%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B/"/>
    <url>/2025/01/11/Redis%E7%9A%845%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul><li>String最基本的编码方式是RAW，即简单动态字符串SDS。存储上限为512MB<br><img src="https://gitee.com/hongtao945/imgs/raw/master/image-20250111153514836.png" alt="RAW编码格式"></li><li>如果存储的SDS长度小于44字节，则会采用<strong>EMBSTR</strong>编码，此时object head与SDS是一段连续空间。申请内存时只需要调用一次内存分配函数，效率更高。</li></ul><p><img src="https://gitee.com/hongtao945/imgs/raw/master/image-20250111153755241.png" alt="EMBSTR编码格式"></p><ul><li>如果存储的字符串是整数值，并且大小在LONG_MAX范围内，则会采用INT编码:直接将数据保存在RedisObject的ptr指针位置(刚好8字节)，不再需要SDS了。</li></ul><p><img src="https://gitee.com/hongtao945/imgs/raw/master/image-20250111154050267.png" alt="INT编码格式"></p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>Redis的List结构类似一个双端链表，可以从首、尾操作列表中的元素<br>在3.2版本之前，Redis采用ZipList和LinkedList来实现List，当元素数量小于512并且元素大小小于64字节时采用ZipList编码，超过则采用LinkedList编码。<br>在3.2版本之后，Redis统一采用QuickList来实现List<br>结构如下:</p><p><img src="https://gitee.com/hongtao945/imgs/raw/master/image-20250111195744609.png" alt="List的结构图"></p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set是Redis中的集合，不一定确保元素有序，可以满足元素唯一、查询效率要求极高。</p><ul><li>为了查询效率和唯一性，set采用HT编码(Dict)。Dict中的kev用来存储元素，value统一为null。</li><li>当存储的所有数据都是整数，并且元素数量不超过set-max-intset-entries时，Set会采用Intset编码，以节省内存。</li></ul><p>结构图：</p><p><img src="https://gitee.com/hongtao945/imgs/raw/master/image-20250111202057136.png" alt="Set结构图——IntSet编码格式"></p><p><img src="https://gitee.com/hongtao945/imgs/raw/master/image-20250111202223353.png" alt="Set结构图——Dict编码格式"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/01/10/Redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/01/10/Redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="用户空间和内核空间"><a href="#用户空间和内核空间" class="headerlink" title="用户空间和内核空间"></a>用户空间和内核空间</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/01/10/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2025/01/10/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="动态字符串SDS"><a href="#动态字符串SDS" class="headerlink" title="动态字符串SDS"></a>动态字符串SDS</h2><p>Redis虽然是使用C语言实现的，但它并没有直接使用C语言的字符串。因为C语言的字符串存在以下问题：</p><ol><li>获取字符串长度需要遍历整个字符串，时间复杂度为O(n)。</li><li>C语言的字符串是以’\0’结尾的，不能存储’\0’字符，所以是非二进制安全的。</li><li>不可修改，修改字符串需要重新分配内存。<figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 本质其实是字符数组，保存的内容为: &#123;'h', 'e', 'l', 'l', 'o', '\0'&#125;</span><span class="token keyword">char</span> <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure>String类型底层使用的是<strong>简单动态字符串</strong>SDS，SDS是Redis自己实现的字符串类型，相比C语言的字符串更加安全。<br>SDS是一个结构体，结构如下：</li></ol><p><img src="https://gitee.com/hongtao945/imgs/raw/master/image-20250110204912483.png" alt="image-20250110204912483"></p><p>SDS是具有动态扩容能力的，例如一个内容为”hi”的SDS:</p><p><img src="https://gitee.com/hongtao945/imgs/raw/master/image-20250110205248229.png" alt="image-20250110205248229"><br>动态字符串相比于C语言的字符串有以下优点：</p><ol><li>获取字符串长度的时间复杂度为O(1)。</li><li>二进制安全，可以存储’\0’字符。</li><li>支持动态扩容。</li><li>减少内存分配次数(每次申请都会多预留一些空间，减少内存分配次数)。</li></ol><h2 id="IntSet"><a href="#IntSet" class="headerlink" title="IntSet"></a>IntSet</h2><p>IntSet是Redis中<strong>set集合</strong>的一种实现方式，基于<strong>整数数组</strong>来实现，并且具备长度可变、有序特征。<br>IntSet的结构如下：</p><p><img src="https://gitee.com/hongtao945/imgs/raw/master/image-20250110205932201.png" alt="image-20250110205932201"></p><p>这里需要对contents做一些解释：contents用于保存实际的数据，这个数组的总长度实际是<code>encoding * length</code>，其中encoding表示数组中元素的类型，有三种类型：INTSET_ENC_INT16表示每个元素用2个字节存储，INTSET_ENC_INT32表示每个元素用4个字节存储，INTSET_ENC_INT64表示每个元素用8个字节存储。<br>而且，IntSet可能会随着数据的添加而改变它的数据编码：</p><ul><li>最开始，新创建的intset使用占内存最小的INTSET_ENC_INT16（值为2）作为数据编码。</li><li>每添加一个新元素，则根据元素大小决定是否对数据编码进行升级。</li></ul><p>为了方便查找，Redis会将IntSet中的数据按照升序保存在contents数组中，如下面这个例子：</p><p><img src="https://gitee.com/hongtao945/imgs/raw/master/image-20250110211039688.png" alt="IntSet内存结构图"></p><p>在IntSet升级的过程中，会按照<strong>倒序</strong>的方式将原来的数据拷贝到扩容后的正确位置，倒序的原因是为了避免数据覆盖的问题。</p><p>总结: IntSet可以看做是特殊的整数数组，具备以下特点:</p><ul><li>Redis会确保Intset中的元素唯一、有序</li><li>具备类型升级机制，可以节省内存空间</li><li>底层采用二分查找方式来查询</li></ul><h2 id="Dict"><a href="#Dict" class="headerlink" title="Dict"></a>Dict</h2><p>Dict是Redis中<strong>字典</strong>的一种实现方式，基于<strong>哈希表</strong>来实现，哈希表是一种用于存储键值对的数据结构，可以快速的查找、插入、删除键值对。<br>Dict由三部分组成：哈希表(DictHashTable)、哈希节点(DictEntry)、字典(Dict)<br>结构体定义如下：</p><p><img src="https://gitee.com/hongtao945/imgs/raw/master/image-20250110213122117.png" alt="哈希表和哈希节点的结构体定义"></p><p>当向哈希表中添加一个键值对时，Redis会根据key计算出一个哈希值h，然后根据h &amp; sizemask计算出一个索引值，将键值对插入到哈希表的索引位置。如果插入的位置已经有数据了，那么就会发生<strong>哈希冲突</strong>，Redis会采用<strong>链地址法</strong>来解决冲突，即将新的键值对插入到链表的头部。如下图所示：</p><p><img src="https://gitee.com/hongtao945/imgs/raw/master/image-20250110213729952.png" alt="哈希表示意图"></p><p>前文提到Dict有三部分，剩下的Dict的结构如下：</p><p><img src="https://gitee.com/hongtao945/imgs/raw/master/image-20250110214020157.png" alt="dict结构体示意图"><br>对于ht[0]和ht[1]，Redis采用<strong>渐进式rehash</strong>的方式来进行扩容，即在扩容的过程中，会同时维护两个哈希表，当需要对ht[0]进行扩容时，会将ht[0]中的数据慢慢迁移到ht[1]中，迁移完成后，再释放ht[0]的内存。一般我们使用的是ht[0], ht[1]一般都是空的。</p><p>整体的结构如下：</p><p><img src="https://gitee.com/hongtao945/imgs/raw/master/image-20250110214430144.png" alt="Dic的结构示意图"></p><h3 id="Dict的rehash"><a href="#Dict的rehash" class="headerlink" title="Dict的rehash"></a>Dict的rehash</h3><p>Dict中的HashTable就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。<br>Dict每次新增键值对的时候都会检查负载因子(LoadFactor &#x3D; dict-&gt;used &#x2F; dict-&gt;size)，满足以下两个条件之一时，就会触发rehash操作进行扩容：</p><ol><li>哈希表的 LoadFactor&gt;&#x3D;1。并且服务器没有执行 BGSAVE 或者 BGREWRITEAOF 等后台进程;</li><li>哈希表的 LoadFactor&gt;5;<br>扩容后的大小为2^n^，2^n^是大于等于dict-&gt;used的最小值，扩容后会重新计算每个键值对的索引值，然后将其插入到新的哈希表中。</li></ol><p>Dict除了扩容以外，还会在删除键值对的时候检查负载因子，如果LoadFactor&lt;0.1，则会触发rehash操作进行缩容。</p><p>不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask变化，而kev的查询与sizemask有关。因此必须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为rehash。过程是这样的:</p><ul><li>计算新hash表的realSize，值取决于当前要做的是扩容还是收缩：<ul><li>如果是扩容，则新size为第一个大于等于dict.ht[0].used+1的2^n^</li><li>如果是收缩，则新size为第一个大于等于dict.ht[0].used的2^n^(不得小于4)</li></ul></li><li>按照新的realeSize申请内存空间，创建dictht，并赋值给dict.ht[1]</li><li>设置dict.rehashidx&#x3D;0，标示开始rehash</li><li>每次执行新增、查询、修改、删除操作时，都检查一下dict.rehashidx是否大于-1，如果是则将dict.ht[0].table[rehashidx]的entry链表rehash到dict.ht[1]，并且将rehashidx++。直到dict.ht[0]的所有数据都rehash到dict.ht[1]</li><li>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</li><li>将rehashidx赋值为-1，代表rehash结束</li><li>在rehash过程中，新增操作，则直接写入ht[1]，查询、修改和删除则会在dict.ht[0]和dict.ht[1]依次查找并执行。这样可以确保ht[0]的数据只减不增，随着rehash最终为空</li></ul><h2 id="ZipList-压缩列表"><a href="#ZipList-压缩列表" class="headerlink" title="ZipList(压缩列表)"></a>ZipList(压缩列表)</h2><p>ZipList是Redis中<strong>列表</strong>和<strong>哈希</strong>的一种实现方式，基于<strong>连续内存</strong>来实现，ZipList是一种特殊的列表，可以存储多个元素，且每个元素的长度不固定，不会像普通的链表那样存储指针，从而节省内存空间。ZipList可以在任意一端进行插入、删除操作，时间复杂度为O(1)。</p><p>特性：<br>压缩列表的可以看做一种连续内存空间的”双向链表”，但是列表的节点之间不是通过指针连接，而是记录上一节点和本节点长度来寻址，因此内存占用较低。<br>如果列表数据过多，导致链表过长，可能影响查询性能。而且增或删较大数据时有可能发生连续更新问题。</p><h2 id="QuickList"><a href="#QuickList" class="headerlink" title="QuickList"></a>QuickList</h2><p>问题1:ZipList虽然节省内存，但申请内存必须是连续空间，如果内存占用较多，申请内存效率很低。怎么办?<br>为了缓解这个问题，我们必须限制ZipList的长度和entry大小。<br>问题2:但是我们要存储大量数据，超出了ZipList最佳的上限该怎么办?<br>我们可以创建多个ZipList来分片存储数据。<br>问题3:数据拆分后比较分散，不方便管理和查找，这多个ZipList如何建立联系?<br>Redis在3.2版本引入了新的数据结构QuickList，它是一个双端链表，只不过链表中的每个节点都是一个ZipList。</p><p>QuickList是Redis中<strong>列表</strong>的一种实现方式，基于<strong>双向链表</strong>和<strong>压缩列表</strong>来实现，QuickList是一个双向链表的数组，每个节点都是一个压缩列表。</p><p>为了避免QuickList中的每个ZipList中entry过多，Redis提供了一个配置项:<code>list-max-ziplist-size</code>来限制。如果值为正，则代表ZipList的允许的entry个数的最大值<br>如果值为负，则代表ZipList的最大内存大小，分5种情况:<br>① -1:每个ZipList的内存占用不能超过4kb<br>② -2:每个ZipList的内存占用不能超过8kb<br>③ -3:每个ZipList的内存占用不能超过16kb<br>④ -4:每个ZipList的内存占用不能超过32kb<br>⑤ -5:每个ZipList的内存占用不能超过64kb<br>其默认值为 -2</p><p>除了控制ZipList的大小，QuickList还可以对节点的ZipList做压缩。通过配置项list-compress-depth来控制。因为链表一般都是从首尾访问较多，所以首尾是不压缩的。这个参数是控制首尾不压缩的节点个数:</p><ul><li>0:特殊值，代表不压缩</li><li>1:标示QuickList的首尾各有1个节点不压缩，中间节点压缩</li><li>2:标示QuickList的首尾各有2个节点不压缩，中间节点压缩</li><li>以此类推<br>默认值为 0</li></ul><p>QuickList的结构体如下：</p><p><img src="https://gitee.com/hongtao945/imgs/raw/master/image-20250111150021442.png" alt="quickList和quickListNode结构体"></p><p>QuickList的结构如下：</p><p><img src="https://gitee.com/hongtao945/imgs/raw/master/image-20250111150244880.png" alt="QuickList结构图"></p><p>compress设置为1，因此首位节点不压缩，中间节点压缩。压缩完以后肉眼看不出来，但是内存占用会减少。</p><p>QuickList的特点:</p><ul><li>是一个节点为ZipList的双端链表</li><li>节点采用ZipList，解决了传统链表的内存占用问题</li><li>控制了ZipList大小，解决连续内存空间申请效率问题</li><li>中间节点可以压缩，进一步节省了内存</li></ul><h2 id="SkipList"><a href="#SkipList" class="headerlink" title="SkipList"></a>SkipList</h2><p>SkipList是Redis中<strong>有序集合</strong>的一种实现方式，基于<strong>跳表</strong>来实现，跳表是一种<strong>有序</strong>的数据结构，可以快速的查找、插入、删除元素。SkipList是一种多层链表，每一层都是一个有序的链表，最底层的链表包含所有元素，而上层的链表包含的元素是下层链表的子集。</p><p>SkipList的结构体定义如下：</p><p><img src="https://gitee.com/hongtao945/imgs/raw/master/image-20250111151104786.png" alt="SkipList的结构体"></p><p>SkipList的结构如下：</p><p><img src="https://gitee.com/hongtao945/imgs/raw/master/image-20250111151312545.png" alt="SkipList的结构"></p><h2 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h2><p>RedisObject是Redis中<strong>对象</strong>的一种实现方式，Redis中的数据都是以对象的形式存在的，对象的类型有5种：字符串、列表、哈希、集合、有序集合。RedisObject是一个结构体，结构如下：</p><p><img src="https://gitee.com/hongtao945/imgs/raw/master/image-20250111151936502.png" alt="RedisObject结构体"></p><p>Redis中会根据存储的数据类型不同，选择不同的编码（redisObject结构体中encoding的值）方式，共包含11种不同类型:</p><p><img src="https://gitee.com/hongtao945/imgs/raw/master/image-20250111152132748.png" alt="encoding的取值范围"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/01/09/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/2025/01/09/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="1-使用Redis实现分布式锁"><a href="#1-使用Redis实现分布式锁" class="headerlink" title="1. 使用Redis实现分布式锁"></a>1. 使用Redis实现分布式锁</h2><h3 id="为什么使用Redis实现分布式锁？"><a href="#为什么使用Redis实现分布式锁？" class="headerlink" title="为什么使用Redis实现分布式锁？"></a>为什么使用Redis实现分布式锁？</h3><ul><li>Redis是高性能的内存数据库，满足高并发的需求。</li><li>Redis支持原子性操作，能保证操作的原子性和一致性。</li><li>Redis支持集群部署，支持多节点间数据同步和复制，实现了高可用和高容错。</li></ul><h3 id="使用Redis的setnx命令实现分布式锁的原理"><a href="#使用Redis的setnx命令实现分布式锁的原理" class="headerlink" title="使用Redis的setnx命令实现分布式锁的原理"></a>使用Redis的setnx命令实现分布式锁的原理</h3><p>setnx命令是Redis的一个原子性操作命令，用于设置一个key-value键值对，如果key不存在，则设置成功，返回1；如果key已经存在，则设置失败，返回0。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># value是一个唯一的标识，可以是UUID或者当前时间戳，后续只有拥有这个value的客户端才能删除这个key</span>setnx key value ex <span class="token number">10</span><span class="token builtin class-name">set</span> key vaule nx ex <span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>接下来使用Java代码来实现一个简易的基于Redis的分布式锁：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> lockName <span class="token operator">=</span> <span class="token string">"lockName"</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> redistemplate<span class="token punctuation">;</span><span class="token comment">// 自旋的方式获取锁，</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Boolean</span> isLock <span class="token operator">=</span> redistemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>lockName<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">Boolean<span class="token punctuation">.</span>True</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>isLock<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 释放锁</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  redistemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>lockName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这个锁目前存在哪些问题呢？</p><ul><li>互斥性</li></ul><p>显然在Redis的setnx命令中，已经保证了互斥性，因为setnx是一个原子性操作，只有一个客户端能够成功设置key，其他客户端都会失败。所以互斥性是满足的。</p><ul><li>可重入性</li></ul><p>可重入性是指一个线程在持有锁的情况下，能够再次获取这个锁，而不会被阻塞。上面的代码中，如果一个线程在持有锁的情况下再次调用lock方法，会发生什么呢？会发生死锁，因为这个线程已经持有锁，但是又在自旋获取锁，所以会一直自旋下去。所以这个锁是不可重入的。</p><ul><li>锁超时，死锁</li></ul><p>在上面的代码中，锁是没有超时时间的，如果一个线程获取锁之后，发生了异常，导致没有释放锁，那么其他线程就会一直等待下去，导致发生死锁。所以我们可以给锁设置一个超时时间，当超过这个时间，锁自动释放。而如果设置了超时时间，又会出现另一个问题，就是当锁的有效时间小于业务执行时间时，会导致锁的提前释放，使得其他线程获取到锁，这就违背了锁的原则。</p><ul><li>正确释放锁，防止误删</li></ul><p>在上面的代码中，释放锁的操作不需要判断当前线程是否持有锁，直接删除key就行了。如果当前线程没有持有锁，那么就会导致误删其他线程的锁，所以我们需要在释放锁的时候，判断当前线程是否持有锁。</p><ul><li>公平和非公平</li></ul><p>上面的代码是非公平的，因为获取锁的时候，是自旋的方式，后来的线程可能会比先前的线程先获取到锁。</p><ul><li>阻塞和非阻塞</li></ul><p>上面的代码是阻塞的，如果获取锁失败，会一直自旋下去，直到获取到锁。如果是非阻塞的，获取锁失败，会立即返回，不会一直等待。</p><p>所以，目前这个简单的基于Redis的分布式锁还存在很多问题，除了满足互斥性，其他的问题都没有解决。接下来我们继续优化这个分布式锁。</p><h3 id="Redisson实现分布式锁"><a href="#Redisson实现分布式锁" class="headerlink" title="Redisson实现分布式锁"></a>Redisson实现分布式锁</h3><ul><li>Redisson是如何解决可重入问题的？<br>Redisson使用hash + lua来记录线程id和重入次数，当一个线程再次获取锁时，会判断线程id是否相同，如果相同，则重入次数+1，否则获取锁失败。</li><li>Redisson是如何获取锁不可重试问题的？<br>Redisson使用信号量和pubsub功能实现等待、唤醒功能实现了获取锁失败的重试机制。</li><li>Redisson是如何解决锁超时问题的？<br>Redisson使用了watchdog机制，当一个线程获取锁成功后，会启动一个watchdog线程，定时（releaseTime &#x2F; 3）刷新锁的过期时间，如果锁的过期时间小于业务执行时间，会自动续期。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/12/28/hello-world/"/>
    <url>/2024/12/28/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test08</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> arrayList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> threadCount <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token class-name">CountDownLatch</span> latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>threadCount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span>threadCount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> finalI <span class="token operator">=</span> i<span class="token punctuation">;</span>        executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>finalI<span class="token punctuation">)</span><span class="token punctuation">;</span>            latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Expected size: "</span> <span class="token operator">+</span> threadCount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Actual size: "</span> <span class="token operator">+</span> arrayList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
